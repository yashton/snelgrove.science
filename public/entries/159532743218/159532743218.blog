{
  "body": "<p>I spent quite some time thinking why I don&rsquo;t understand the development practice of most programmers I&rsquo;ve encountered. I realized there is a major gap in thinking between us. I&rsquo;ve formulated this as two distinct camps - result oriented and system oriented. Obviously no organization or person will fit squarely in one camp, but I have found it a useful distinction.</p>\n\n<h1>Results oriented</h1>\n\n<p>Runtime behavior is your business product. Code is a means to an end.</p>\n\n<p><strong>Key indicator</strong>: someone would buy your company for your client base.</p>\n\n<p>Concerned with generating income.</p>\n\n<p><strong>Now</strong> oriented.</p>\n\n<h2>Typical patterns</h2>\n\n<ul><li>UI first.</li>\n<li>Heavy reliance on frameworks (fallback to website always).</li>\n<li>Use familiar tools beyond original purpose</li>\n<li>First thing that compiles.</li>\n<li>Customer driven. Very reactive.</li>\n<li>Test driven development (result first).</li>\n<li>Shortest path from point A to point B</li>\n</ul><h2>Interests</h2>\n\n<ul><li>Short term growth</li>\n<li>Quick, reactive development</li>\n<li>Technical debt is acceptable</li>\n<li>Simpler problems solvable with a tool.</li>\n</ul><h2>Failure modes</h2>\n\n<ul><li>Technical debt outpacing growth</li>\n<li>Intractable problems - e.g. not solvable in short time, requires new techniques, not suitable for current tools.</li>\n<li>Over promising features</li>\n</ul><h1>System oriented</h1>\n\n<p>Code is the product. Runtime behavior is a result of the product working</p>\n\n<p><strong>Key indicator</strong>: someone would buy your company for your technology.</p>\n\n<p>Concerned with building capital.</p>\n\n<p><strong>Future</strong> oriented.</p>\n\n<h2>Typical patterns</h2>\n\n<ul><li>System and data first.</li>\n<li>Architecture driven.</li>\n<li>Stakeholder driven.</li>\n<li>Planned features.</li>\n<li>Builds tools.</li>\n</ul><h2>Interests</h2>\n\n<ul><li>Sustainable product.</li>\n<li>Patents and Licensing.</li>\n<li>Long term stability.</li>\n<li>Harder problems requiring new technology</li>\n</ul><h2>Failure modes</h2>\n\n<ul><li>Perfectionism</li>\n<li>Failure to deliver</li>\n<li>Over engineering (you ain&rsquo;t gonna need it).</li>\n<li>Unresponsive to customer needs.</li>\n</ul><p>I think the split represents what I&rsquo;m seeing in most software shops - they are pretty much solely focused on results rather than systems. The first code that gets the results they want is the correct solution and then move on. I&rsquo;ve watched devs with years of experience write brand new code which contains functions in the thousands of lines. They were unable to describe the functioning interactions in their code that they had written in the previous month. The code was not a system; but rather a large growing collection of functionality drifting as needed.</p>\n\n<p>I&rsquo;m very clearly in the system oriented thinking camp. I like to say that if you do your job right, no one will notice, which is probably true. The result oriented person appears to be much more productive since they are in the thick of reacting to problems and immediate needs. They also move quickly, because future consequences are not at the forefront of their thinking.</p>\n\n<p>Proactive maintenance is very system oriented. Reactive changes to failures or criticism represent result driven thinking. If something isn&rsquo;t actively an emergency it gets ignored. When you find a major problem, they quickly became interested in fixing the problem because the result was wrong. If they don&rsquo;t see the incorrect result, it&rsquo;s not a problem.</p>\n\n<p>I think that much of my struggles have come from being at odds with other people&rsquo;s goals. If I&rsquo;m pushing for a longer dev time on a project to add unit tests or do some refactoring, I&rsquo;m adding more work, not reducing it. The result is already done, why make it harder for yourself? I haven&rsquo;t figured out the best way to align long term pain with good practice and consequences  with current behavior.</p>\n\n<p>On the flip side, I have struggled against the failure modes of the system oriented camp. Over engineering in particular is a struggle. My deep investment in backend and infrastructure over user interfaces and the whims of customers has frustrated people, making them think that I have no interest in their needs.</p>",
  "posted_month": "2017-04-13",
  "posted": "2017-04-13T11:02:35",
  "objectID": "159532743218",
  "tags": ["programming"],
  "posted_timestamp": 1492102955,
  "title": "Results vs System oriented thinking"
}
