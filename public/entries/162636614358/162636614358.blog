{
  "body": "<p>Usually we talk about programming languages in their literal syntax - BNF trees, keywords, all that raw characters on the buffer. &ldquo;Dialects&rdquo; would be something like gcc vs Visual C++, or the &ldquo;ML family&rdquo;. We talk about &ldquo;style&rdquo; as the perennial flame war elements like braces and variable names. Compare the Linux style guide to something like AS Style or Oxford. It&rsquo;s all about the elements on the page, not the content.</p>\n\n<p>I&rsquo;m thinking this is the wrong idea (or at least too low a level). Each programmer has their own style of writing, patterns they use, the structures they prefer, techniques they use, architecture and code organization. It&rsquo;s like a writer in English or any other language: just because you know vocab and syntax doesn&rsquo;t make you Shakespeare.</p>\n\n<p>Like most languages, we learn primarily by imitation. You learn your idioms from your peer group - if they talk a certain way, you will too. I often feel like a fish out of water because my colleagues are speaking one dialect or broken English, and I&rsquo;m speaking something more formal. I can understand them, but it&rsquo;s not particularly elegant. I certainly have my own idiosynchrasies and biases in my personal style. Maybe we fight so much about braces because it&rsquo;s as much a proxy for the real dialect differences.</p>\n\n<p>Frameworks gain an additional facet when you consider them in the context of writing. The 3 paragraph essay is the strongest example I can think of. The writer is &ldquo;filling in the form&rdquo; when they write.  I always wanted to push beyond the format. Freeform writing is quite hard for many people. Starting with a blank page or buffer is paralyzing. Something like Rails or another strongly opinionated framework fits the same concept. Hiring someone who &ldquo;knows Rails&rdquo; is implicitly hoping that they write the same idiom. Consider a sonnet as more of an &ldquo;architecture&rdquo; - constraining to a structure. More freeform writing takes more discipline and skill to prevent it from jumbling into a mess - and it can still be difficult to understand. Writing spaghetti is just some crazy dude shouting at people you can&rsquo;t see. We as an industry do a lot of raving and shouting.</p>\n\n<p>In the end, one person is not going to affect any significant change in idiom or dialect of another, except through osmosis. The only way you learn is reading good code. Any writer who claims don&rsquo;t read other writer&rsquo;s work so they can maintain their own idependence is a third rate hack. Code reviews or pairing are the most direct way to get exposure. Reading other&rsquo;s code, especially open source. Use terminology from the state of the art. Don&rsquo;t anthropomorphise the machine. Introspection is the final key technique - critical reading of your own writing.</p>\n\n<p>Setting the pace initially for an organization really makes a difference. One Shakespeare doesn&rsquo;t make the whole crew writers, but it will set pace, and give something to emulate. Also for rising stars, their best bet is to apprentice to a good writer so they learn all the good habits and not the bad ones. Your first job is probably the most formative experience.</p>\n\n<p>I do believe there are masters out there with a high level of language and idiom. Given that our discipline is highly technical, I don&rsquo;t expect flowery prose. But clear, concise, well architeched code is a critical aspiration.</p>\n\n<p>&ldquo;Expressiveness&rdquo; is a word bandied about a lot. I think there are a couple meanings.</p>\n\n<ul><li>High information content. DSLs and scripting languages, especially Python (one way to do it). Jargon and idiom are there to condense information. Higher level languages attempt to remove boilerplate and legwork like memory management so the focus is on the information. DSLs are supposed to be even more information dense. A frequent complaint is that you don&rsquo;t have full ability to express <em>anything</em> you want if it isn&rsquo;t in the vocab. Failure mode is something like Perl and regex - so informationally dense it becomes impossible tangle.</li>\n<li>Flexibility. C is ur-example, but dynamic programming languages or macros make the cut. You can skin the crap out of that cat. Information density may be low, but granularity is high. Failure mode is basically reinventing a DSL, or losing the high level information in the boilerplate; illegibility becomes a problem. Good for telling the machine exactly what to do (see next item), or being clever.</li>\n<li>Working in the wrong paradigm. Trying to write functional programming in Java, OOP Java in Scala, or any other way of talking crosswise. Usually a complaint rather than an expression of support. The language doesn&rsquo;t provide structures or features to write code in a certain way, or they are more verbose. Usually someone ends up trying to write the missing functionality into the language.</li>\n</ul>",
  "posted_month": "2017-07-05",
  "posted": "2017-07-05T12:19:20",
  "objectID": "162636614358",
  "tags": ["programming"],
  "posted_timestamp": 1499278760,
  "title": "Language and Idiom in Programming Languages"
}
