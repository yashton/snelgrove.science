{
  "body": "<p><em>&ldquo;Any fool can write code that a computer can understand. Good programmers write code that humans can understand.&rdquo; Martin Fowler, 2008</em></p>\n\n<p>If you can&rsquo;t measure it, you can&rsquo;t change it!</p>\n\n<h2>The Schizophrenia of Computing</h2>\n\n<p>Computer science is a branch of mathematics.\nComputer engineering is a branch of electrical engineering.\nSoftware engineering is a branch of sociology.\nBalance the three if you can.</p>\n\n<h2>Clean Code</h2>\n\n<ul><li>Write code so the poor bastard after you doesn&rsquo;t curse your name.</li>\n<li>Code with intention.</li>\n<li>Immutable &gt; Mutable</li>\n<li>Data &gt; State</li>\n<li>Separation of concerns &gt; tight coupling</li>\n<li>Composition &gt; Inheritance</li>\n<li>Explicit &gt; Implicit</li>\n<li>Polymorphism &gt; Conditional</li>\n<li>Polymorphism != Code sharing (OOP does not require inheritance or abstract classes)</li>\n<li>Functional &gt; Imperative</li>\n<li>Declarative &gt; imperative (i.e. what &gt; how)</li>\n<li>Abstraction &gt; Code grouping</li>\n<li>Clean code &gt; needless optimization</li>\n<li>referential transparency (account for all inputs, all outputs including exceptions)</li>\n<li>small sharp tools (do one thing, and do it well)</li>\n<li>Build composable tools.</li>\n<li>high signal to noise ratio.</li>\n<li>Separate structural changes from behavioral changes.</li>\n<li>Limit inheritance.</li>\n<li>Maintain locality of functionality.</li>\n<li>Develop personal craftsmanship. Never stop learning.</li>\n</ul><h2>Architecture</h2>\n\n<ul><li>Domain &gt; Code</li>\n<li>Why -&gt; What -&gt; How</li>\n<li>Build heirarchies of systems.</li>\n<li>Asynchronous first.</li>\n<li>Data &gt; Code</li>\n<li>Code &gt; Configuration</li>\n<li>Code &gt; Convention</li>\n<li>Tests &gt; Documentation</li>\n<li>Create APIs. Start with client/server</li>\n<li>Establish boundaries and surfaces.</li>\n<li>Choose the right tool not just the tool you have.</li>\n<li>Caller &gt; Callee. Don&rsquo;t push concerns into the callee.</li>\n<li>&ldquo;First thing that compiles&rdquo; is not an acceptable engineering decision.</li>\n<li>Actors &gt; Objects (or rather, actors encapsulate better than objects.)</li>\n<li>Website is not an architecture</li>\n<li>&ldquo;There is nothing more permanent than a temporary fix.&rdquo;</li>\n<li>Encapsulate state in state machines.</li>\n</ul><h2>Testing and Error handling</h2>\n\n<ul><li>Test around separation of concerns</li>\n<li>Test for behavior.</li>\n<li>Fail loud, fail fast</li>\n<li>Edge case handling &gt; Make it go away</li>\n<li>Understanding how things work &gt; sacrificing to the elder gods and hoping things happen</li>\n<li>test for stability</li>\n<li>Errors are a failure in the design or implementation of code. Exceptions are output of your function.</li>\n<li>Mocking is a smell that you have too many dependencies.</li>\n</ul><h2>Data</h2>\n\n<ul><li>Data &gt; State. State is data that is variant over time.</li>\n<li>structured types &gt; dynamic data</li>\n<li>explicit schema &gt; implicit schema</li>\n<li>Immutability &gt; mutability</li>\n<li>Data transforms &gt; tickling</li>\n<li>Serialize at boundaries only.</li>\n<li>Cannot promote derived data.</li>\n<li>Null considered harmful. Use explicit definitions to indicate &ldquo;value may not be present&rdquo;.</li>\n<li>Objects and structures should be in a stable state once they leave the constructor.</li>\n</ul><h2>Concurrency</h2>\n\n<ul><li>Event-driven / Reactive &gt; Explicit calls</li>\n<li>Asynchronous &gt; Synchronous</li>\n<li>Can treat local as remote, but not vice versa.</li>\n<li>Time is a continuum.</li>\n<li>Communication &gt; synchronized state</li>\n<li>Separate context of execution from behavior.</li>\n<li>Threads and processes are contexts of execution, not concurrency primitives.</li>\n<li>Share nothing.</li>\n</ul><h2>Code reviews</h2>\n\n<ol><li>Does this represent one change?</li>\n<li>Does it present clean system surfaces? (Does everything fit together.)</li>\n<li>Does it present clean public surfaces? (Is it useable)</li>\n<li>Automated tests. (Does it do what it should around the surfaces?)</li>\n<li>Style (Is it clear and readable?)</li>\n</ol>",
  "posted_month": "2017-01-18",
  "posted": "2017-01-18T10:33:39",
  "objectID": "156042816313",
  "tags": ["programming"],
  "posted_timestamp": 1484760819,
  "title": "Principles of Building Software"
}
