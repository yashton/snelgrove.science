{
  "body": "<p>In line with my <a href=\"http://snelgrove.science/post/159532743218/results-vs-system-oriented-thinking\">results vs system thinking exploration</a>, I think I&rsquo;ve found what may be another dichotomy in software development practice. The tool over framework principle has been fundamental for my engineering practice for my whole professional career. Composable tools have served me better than large frameworks. Usually I&rsquo;ve considered it a style choice with consequences, but it may represent a more fundamental attitude towards engineering. Even if your system doesn&rsquo;t use an explicit 3rd party software framework, the framework way of thinking may be present. As always, this is not a black &amp; white descriptor.</p>\n\n<h1>Tools</h1>\n\n<ul><li>Unix principle: do one thing and do it well</li>\n<li>Composable tools provide platform as needed.</li>\n<li>Enable and empower.</li>\n<li>Give developers tools to build with.</li>\n<li>Intimately familiar with tools.</li>\n<li>Likes new tools, actively adopts them.</li>\n<li>Likes the command line.</li>\n<li>Learns by reading source and documentation.</li>\n<li>Vertical development.</li>\n</ul><h2>Benefits</h2>\n\n<ul><li>Flexibility.</li>\n<li>Reusable and composible functionality. Encapsulation.</li>\n<li>Application performance from choosing only the tools needed.</li>\n<li>Adoption of new tools rather than building.</li>\n<li>Reduce costs by leveraging the best tools.</li>\n</ul><h2>Costs</h2>\n\n<ul><li>Upfront investment in learning multiple tools</li>\n<li>Fragmentation of implementation.</li>\n<li>Emergent behavior between tools and components.</li>\n<li>Complexity of system.</li>\n<li>Fragility</li>\n</ul><h1>Frameworks</h1>\n\n<ul><li>Microsoft principle: play in our garden, it&rsquo;s got everything you could need</li>\n<li>convention over configuration.</li>\n<li>Insulate and focus.</li>\n<li>Give developers places to slot in logic. Frameworks provide all platform details.</li>\n<li>Likes IDEs.</li>\n<li>Always wants familiar tools. Distrusts new tools or new uses of tools.</li>\n<li>Learn tools to the level that the benefit is achieved, no further.</li>\n<li>Learns by example and imitation. Likes recipes and copy/paste.</li>\n<li>Web frameworks as ur-example.</li>\n<li>Horizontal development.</li>\n</ul><h2>Benefits</h2>\n\n<ul><li>Knowledge transfer between organizations. (&ldquo;Looking for a Rails developer&hellip;&rdquo;)</li>\n<li>Quick turnaround from idea to something presentable.</li>\n<li>Commercial tools and support.</li>\n<li>Reduce costs by focusing on business logic over implementation details.</li>\n</ul><h2>Costs</h2>\n\n<ul><li>Founders once framework no longer provides functionality.</li>\n<li>Sprawl and inertia.</li>\n<li>Reiventing the wheel, ineffective tool use.</li>\n<li>Duplication and redundancy.</li>\n</ul><h1>Horizontal vs vertical</h1>\n\n<p>Tool and framework nicely describe an attitude a developer or team has towards their work. There are two descriptors of the software projects themselves I&rsquo;ve used for a while, which I think very closely map to the tool and framework thinking: I call them vertical and horizontal.</p>\n\n<p>A vertical system has narrowly focused independent components, building up complexity through the combination, usually in a heirarchy. Vertical systems leverage tools appropriate at each component.</p>\n\n<p>Horizontal systems are very flat, with many similar broad components at the same level. Horizontal systems leverage frameworks and use the same set of tools for each component.</p>\n\n<p>The classic example of a horizontal system is one using the typical web framework (Rails, Django, Cake, etc). Ostensibly there are layers (a distinct pattern &ldquo;Rails-MVC&rdquo;), but it usually devolves into what I call macaroni code. Each component has a data access system bound to one database table, a routing class, and a UI template. Repeat for every table in your database. Best case, you get these macaroni tubes of functionality from the UI to the datastore. Horizontal development scales well. New functionality can be added without affecting architecture. There is a strong established pattern for devs to follow; it lends itself well to most dev shops and outsourcing firms where developers are mostly low skilled. Functionality is (hopefully) strongly grouped and easy to find. Service oriented architecture to this style means splitting the macaroni into separate processes. Failure modes include; needs beyond the basics of the horizontal layer, problems outside the scope of the framework, unmanageable sprawl, slow moving change. Compare with an assembly line - lots of very similar operations done at a large scale.</p>\n\n<p>Vertical systems are more rare, and less visible due to their general lack of reliance on frameworks. Growth of non-traditional software tools in data analysis, distributed systems, and embedded systems have driven tool development. In the web space, tools like Sinatra and akka-http represent a different approach, providing only routing functionality and expecting other tools to provide for other needs. Akka itself is a great example of providing a set of tools for solving concurrency model problems. Vertical systems are more likely to become spaghetti and fragile, due to the increasing complexity of interconnected components. If each component becomes connected to most of the others, the number of possible connections goes up exponentially. Good vertical systems are build heirarchically, with the complexity managed by abstracting away details of a component&rsquo;s inner workings and subcomponents. Service oriented architecture to this style is just another way to compose the system components together. Compare with an internal combustion engine - distinct components, working together in a complex way.</p>",
  "posted_month": "2017-04-01",
  "posted": "2017-04-13T12:42:47",
  "objectID": "159535541343",
  "tags": ["programming"],
  "posted_timestamp": 1492108967,
  "title": "Tool vs Framework practice"
}
